<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Косынка — одна масть</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      background: #0a3;
      font-family: sans-serif;
      height: 100%;
      overflow: hidden;
      user-select: none;
    }
    #game {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 10px;
    }
    .row {
      display: flex;
      justify-content: space-around;
      margin-bottom: 20px;
    }
    .pile {
      position: relative;
      width: 80px;
      height: 500px;
      background: rgba(255,255,255,0.1);
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: 6px;
      margin: 5px;
    }
    .card {
      position: absolute;
      width: 80px;
      height: 120px;
      background: white;
      border-radius: 6px;
      border: 1px solid #000;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
      color: black;
      cursor: grab;
      padding: 5px;
      transition: transform 0.5s ease-in-out;
    }
    .card .value {
      position: absolute;
      top: 4px;
      left: 6px;
    }
    .dragging {
      opacity: 0.7;
      pointer-events: none;
    }
    #win {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 40px;
      background: #000a;
      color: white;
      padding: 20px;
      border-radius: 12px;
      display: none;
      z-index: 9999;
    }
  </style>
</head>
<body>
  <div id="game">
    <div class="row" id="tableauRow"></div>
    <div class="row">
      <div class="pile" id="foundation"></div>
    </div>
    <div id="win">Победа! Все ♠ собраны.</div>
  </div>

  <script>
    const values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
    const tableauRow = document.getElementById('tableauRow');
    const foundation = document.getElementById('foundation');
    const win = document.getElementById('win');
    const piles = [];
    let deck = [];

    function createDeck() {
      deck = [];
      for (let i = 0; i < values.length; i++) {
        deck.push({ value: values[i], index: i });
      }
      deck = deck.sort(() => Math.random() - 0.5);
    }

    function createCard(data) {
      if (!data || typeof data.index === 'undefined') return null;
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.index = data.index;
      card.dataset.value = data.value;
      const val = document.createElement('div');
      val.className = 'value';
      val.textContent = data.value + '♠';
      card.appendChild(val);
      return card;
    }

    function init() {
      createDeck();
      for (let i = 0; i < 7; i++) {
        const pile = document.createElement('div');
        pile.className = 'pile';
        tableauRow.appendChild(pile);
        piles.push(pile);
        for (let j = 0; j <= i; j++) {
          if (deck.length === 0) continue;
          const cardData = deck.pop();
          const card = createCard(cardData);
          if (card) {
            pile.appendChild(card);
          }
        }
      }
      layoutAllPiles();
      enableDraggableOnTopCards();
    }

    function layoutAllPiles() {
      piles.forEach(pile => {
        const cards = Array.from(pile.children);
        cards.forEach((card, i) => {
          card.style.top = (i * 30) + 'px';
          card.style.left = '';
        });
      });
    }

    function enableDraggableOnTopCards() {
      piles.forEach(pile => {
        const cards = Array.from(pile.children);
        cards.forEach(c => c.onmousedown = null);
        for (let i = 0; i < cards.length; i++) {
          if (isOrderedStack(cards.slice(i))) {
            makeStackDraggable(cards[i]);
            break;
          }
        }
      });
    }

    function isOrderedStack(stack) {
      for (let i = 0; i < stack.length - 1; i++) {
        const a = parseInt(stack[i].dataset.index);
        const b = parseInt(stack[i+1].dataset.index);
        if (a !== b + 1) return false;
      }
      return true;
    }

    function makeStackDraggable(card) {
      card.onmousedown = function(e) {
        e.preventDefault();
        const pile = card.parentElement;
        const cards = Array.from(pile.children);
        const cardIndex = cards.indexOf(card);
        const movingStack = cards.slice(cardIndex);
        if (!isOrderedStack(movingStack)) return;

        const offsets = movingStack.map(c => {
          const rect = c.getBoundingClientRect();
          return {
            card: c,
            offsetX: e.clientX - rect.left,
            offsetY: e.clientY - rect.top
          };
        });

        movingStack.forEach(c => {
          document.body.appendChild(c);
          c.classList.add('dragging');
        });

        function onMouseMove(e) {
          movingStack.forEach((c, i) => {
            c.style.left = (e.pageX - offsets[i].offsetX) + 'px';
            c.style.top = (e.pageY - offsets[i].offsetY + i * 30) + 'px';
          });
        }

        function onMouseUp(e) {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          const targetPile = getDropPile(e.clientX, e.clientY);
          let valid = false;

          if (targetPile) {
            const first = movingStack[0];
            const top = targetPile.lastElementChild;
            if (targetPile === foundation) {
              if (movingStack.length === 1 &&
                ((!top && first.dataset.index === '0') ||
                (top && parseInt(first.dataset.index) === parseInt(top.dataset.index) + 1))) {
                valid = true;
              }
            } else {
              if (!top || parseInt(first.dataset.index) === parseInt(top.dataset.index) - 1) {
                valid = true;
              }
            }
          }

          if (valid && targetPile) {
            movingStack.forEach(c => {
              targetPile.appendChild(c);
            });
          } else {
            movingStack.forEach((c, i) => {
              pile.appendChild(c);
            });
          }

          layoutAllPiles();
          enableDraggableOnTopCards();
          movingStack.forEach(c => c.classList.remove('dragging'));
          checkWin();
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      };
    }

    function getDropPile(x, y) {
      const all = document.querySelectorAll('.pile');
      for (let p of all) {
        const r = p.getBoundingClientRect();
        if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return p;
      }
      return null;
    }

    function checkWin() {
      if (foundation.children.length === 13) {
        win.style.display = 'block';
        const center = foundation.getBoundingClientRect();
        const centerX = center.left + 40;
        const centerY = center.top + 60;

        const allCards = document.querySelectorAll('.card');
        allCards.forEach((card, i) => {
          const rect = card.getBoundingClientRect();
          const dx = centerX - rect.left;
          const dy = centerY - rect.top;
          setTimeout(() => {
            card.style.transform = `translate(${dx}px, ${dy}px) scale(0.5) rotate(${720 + i * 10}deg)`;
          }, i * 50);
        });
      }
    }

    init();
  </script>
</body>
</html>
